{
   "Above declaration will be compiled into the next string.\n" : "上記の宣言は、次の文字列にコンパイルされる。\n",
   "Above examples are shortcut for following code.\n" : "上記の例は、以下のコードのショートカットである。\n",
   "Accessor methods are automatically generated when C<is> parameter is given. If the same function is already defined, the program causes fatal error. Accessors are removed when the object is destroyed. Problems may occur when multiple objects are present at the same time.\n" : "C<is>パラメータが与えられると、アクセサメソッドが自動的に生成されます。同じ関数がすでに定義されている場合、プログラムは致命的なエラーを引き起こします。アクセサはオブジェクトが破棄されると削除されます。複数のオブジェクトが同時に存在する場合、問題が発生する可能性があります。\n",
   "Additional alias names can be specified by B<alias> parameter too. There is no difference with ones in C<spec> parameter.\n" : "B<alias>パラメータで、追加のエイリアス名を指定することもできる。C<spec>パラメータのものと違いはありません。\n",
   "As for C<spec> parameter, label can be omitted if it is the first parameter.\n" : "C<spec>パラメータは、最初のパラメータであればラベルを省略できる。\n",
   "B<Getopt::EX::Hashed> is a module to automate a hash object to store command line option values for B<Getopt::Long> and compatible modules including B<Getopt::EX::Long>. Module name shares B<Getopt::EX> prefix, but it works independently from other modules in B<Getopt::EX>, so far.\n" : "B<Getopt::EX::Hashed>は、B<Getopt::Long>およびB<Getopt::EX::Long>を含む互換モジュールのコマンドラインオプション値を格納するハッシュオブジェクトを自動化するモジュールです。モジュール名は B<Getopt::EX> と同じですが、今のところ B<Getopt::EX> の他のモジュールとは独立して動作します。\n",
   "Because hash keys are protected by C<Hash::Util::lock_keys>, accessing non-existent member causes an error. Use this function to declare new member key before use.\n" : "ハッシュキーはC<Hash::Util::lock_keys>によって保護されているため、存在しないメンバにアクセスするとエラーになります。この関数を使用して、新しいメンバー・キーを宣言してから使用してください。\n",
   "C<GetOptions> has a capability of storing values in a hash, by giving the hash reference as a first argument, but it is not necessary.\n" : "C<GetOptions>は、ハッシュ参照を第1引数に与えることで、ハッシュに値を格納する機能を持っていますが、これは必要ありません。\n",
   "Call appropriate function defined in caller's context to process options.\n" : "オプションを処理するために、呼び出し元のコンテキストで定義された適切な関数を呼び出します。\n",
   "Class method to get initialized hash object.\n" : "初期化されたハッシュオブジェクトを取得するクラスメソッド。\n",
   "Declare option parameters in a following form. The parentheses are for clarity only and may be omitted.\n" : "オプション・パラメータを以下の形式で宣言する。括弧はわかりやすくするためのもので、省略してもよい。\n",
   "Following declarations are almost equivalent, except second one is case insensitive.\n" : "以下の宣言はほぼ等価ですが、2番目の宣言は大文字小文字を区別しません。\n",
   "Following parameters are all for data validation. First C<must> is a generic validator and can implement anything. Others are shortcut for common rules.\n" : "以下のパラメータはすべてデータ・バリデーションのためのものである。最初の C<must> は汎用バリデータで、何でも実装できます。その他は一般的なルールのショートカットである。\n",
   "Following parameters are available.\n" : "以下のパラメータが利用可能である。\n",
   "For example, to define the option C<--number>, which takes an integer value as a parameter, and also can be used as C<-n>, do the following\n" : "たとえば、整数値をパラメータとしてとり、C<-n>としても使えるオプションC<--number>を定義するには、次のようにする。\n",
   "Getopt::EX::Hashed - Hash store object automation for Getopt::Long\n" : "Getopt::EX::Hashed - Getopt::Long 用ハッシュ格納オブジェクトの自動化\n",
   "Give option specification. C<< spec => >> label can be omitted if and only if it is the first parameter.\n" : "オプション指定C<< spec => >> ラベルを省略できるのは、それが最初のパラメータである場合だけである。\n",
   "If a code reference is given, it is called at the time of B<new> to get default value. This is effective when you want to evaluate the value at the time of execution, rather than declaration. If you want to define a default action, use the B<action> parameter.\n" : "コード・リファレンスが与えられると、B<new>の実行時に呼び出され、デフォルト値が得られる。これは、宣言ではなく実行時に値を評価したい場合に有効である。デフォルトのアクションを定義したい場合は、B<action>パラメータを使用します。\n",
   "If a reference to SCALAR is given, the option value is stored in the data indicated by the reference, not in the hash object member. In this case, the expected value cannot be obtained by accessing the hash member.\n" : "SCALARへの参照が与えられた場合、オプション値はハッシュオブジェクトメンバではなく、参照が示すデータに格納されます。この場合、ハッシュ・メンバにアクセスしても期待値は得られません。\n",
   "If array reference is given, multiple names can be declared at once.\n" : "配列参照が与えられている場合、一度に複数の名前を宣言することができます。\n",
   "If multiple code reference is given, all code have to return true.\n" : "複数のコード参照が与えられた場合、すべてのコードが真を返さなければならない。\n",
   "If nothing special is necessary, give empty (or white space only) string as a value. Otherwise, it is not considered as an option.\n" : "特に何もする必要がない場合は、空文字列（または空白のみ）を値として与えます。そうでない場合は、オプションとはみなされません。\n",
   "If the name and aliases contain underscore (C<_>), another alias name is defined with dash (C<->) in place of underscores.\n" : "名前とエイリアスにアンダースコア(C<_>)が含まれている場合、アンダースコアの代わりにダッシュ(C<->)を使った別のエイリアスが定義されます。\n",
   "If the name start with plus (C<+>), given parameter updates existing setting.\n" : "名前がプラス(C<+>)で始まる場合、与えられたパラメータは既存の設定を更新する。\n",
   "If the number of parameter is not even, default label is assumed to be exist at the head: C<action> if the first parameter is code reference, C<spec> otherwise.\n" : "パラメータの数が偶数でない場合、デフォルトのラベルが先頭にあるとみなされます：最初のパラメータがコード参照であればC<action>、そうでなければC<spec>となる。\n",
   "If the value is a reference for ARRAY or HASH, new reference with same member is assigned. This means that member data is shared across multiple C<new> calls. Please be careful if you call C<new> multiple times and alter the member data.\n" : "値が ARRAY または HASH の参照の場合、同じメンバを持つ新しい参照が割り当てられます。つまり、メンバ・データは複数のC<new>呼び出しで共有されます。C<new>を複数回呼び出してメンバ・データを変更する場合は注意してください。\n",
   "If true, read-write accessors have lvalue attribute. Set zero if you don't like that behavior.\n" : "trueを指定すると、読み書き可能なアクセサはlvalue属性を持ちます。この振る舞いを好まない場合はゼロを設定してください。\n",
   "If you are using optional argument, don't forget to include default value in the list. Otherwise it causes validation error.\n" : "オプションの引数を使用する場合は、リストにデフォルト値を含めることを忘れないでください。そうしないとバリデーション・エラーになります。\n",
   "If you don't like assignable accessor, configure C<ACCESSOR_LVALUE> parameter to 0. Because accessor is generated at the time of C<new>, this value is effective for all members.\n" : "C<configure>でC<DEFAULT>パラメータを設定します。アクセサはC<new>時に生成されるので、この値はすべてのメンバに有効です。\n",
   "If you want to access arbitrary keys, unlock the object.\n" : "任意のキーにアクセスしたい場合は、オブジェクトのロックを解除してください。\n",
   "If you want to make accessor for all following members, use C<configure> to set C<DEFAULT> parameter.\n" : "以下のすべてのメンバにアクセッサを作りたい場合は、C<configure>でC<DEFAULT>パラメータを設定します。\n",
   "In I<string>, option spec and alias names are separated by white space, and can show up in any order.\n" : "I<string> では、オプションの仕様とエイリアスの名前は空白で区切られ、どのような順番でも表示できます。\n",
   "Lock hash keys. This avoids accidental access to non-existent hash entry.\n" : "ハッシュ・キーをロックします。これは、存在しないハッシュ・エントリへの偶発的なアクセスを避けるためです。\n",
   "Major objective of this module is integrating initialization and specification into single place. It also provides simple validation interface.\n" : "このモジュールの主な目的は、初期化と仕様を一箇所に統合することです。また、シンプルな検証インターフェイスも提供します。\n",
   "Parameter C<action> takes code reference which is called to process the option. C<< action => >> label can be omitted if and only if it is the first parameter.\n" : "パラメータ C<action> は、オプションを処理するために呼び出されるコード参照をとる。C<<action =>> ラベルは、それが最初のパラメータである場合に限り、省略することができる。\n",
   "Parameter C<must> takes a code reference to validate option values. It takes same arguments as C<action> and returns boolean. With next example, option B<--answer> takes only 42 as a valid value.\n" : "パラメータ C<must> は、オプション値を検証するためのコードリファレンスを受け取ります。C<action> と同じ引数をとり、真偽値を返します。次の例では、オプションB<--answer>は有効な値として42だけを取ります。\n",
   "Produce alias with underscores removed.\n" : "アンダースコアを削除したエイリアスを生成する。\n",
   "Produce alias with underscores replaced by dash.\n" : "アンダースコアをダッシュに置き換えたエイリアスを生成する。\n",
   "Read-write accessor has lvalue attribute, so it can be assigned to. You can use like this:\n" : "読み書き可能なアクセサはlvalue属性を持っているので、それを代入することができます。このように使えます：\n",
   "Reset the class to the original state.\n" : "クラスを元の状態にリセットする。\n",
   "Return option specification list which can be given to C<GetOptions> function.\n" : "C<GetOptions>関数に渡すことができるオプション指定リストを返します。\n",
   "Set default parameters. At the call for C<has>, DEFAULT parameters are inserted before argument parameters. So if both include same parameter, later one in argument list has precedence. Incremental call with C<+> is not affected.\n" : "デフォルト・パラメータを設定する。C<has>の呼び出しでは、DEFAULTパラメータが引数パラメータの前に挿入されます。そのため、同じパラメータが両方に含まれている場合は、引数リストで後の方が優先されます。C<+>によるインクリメンタルコールは影響を受けない。\n",
   "Set default value. If no default is given, the member is initialized as C<undef>.\n" : "デフォルト値を設定します。デフォルト値が指定されない場合、メンバはC<undef>として初期化されます。\n",
   "Set function name called from C<getopt> method.\n" : "C<getopt> メソッドから呼び出される関数名を設定します。\n",
   "Set the minimum and maximum limit for the argument.\n" : "引数の最小値と最大値を設定する。\n",
   "Set the valid string parameter list. Each item is a string or a regex reference. The argument is valid when it is same as, or match to any item of the given list. If the value is not an arrayref, it is taken as a single item list (regexpref usually).\n" : "有効な文字列パラメータリストを設定する。各項目は文字列または正規表現参照である。引数は、指定されたリストのいずれかの項目と同じか一致する場合に有効である。値がarrayrefでない場合は、単一の項目リスト（通常は正規表現）とみなされる。\n",
   "The accessor is created with the first name. In this example, the accessor will be defined as C<< $app->number >>.\n" : "アクセサは最初の名前で作成されます。この例では、アクセサは C<< $app->number >> と定義されます。\n",
   "There are following configuration parameters.\n" : "以下の構成パラメータがあります。\n",
   "This is much simpler than writing as in the following.\n" : "これは、次のように書くよりずっと簡単だ。\n",
   "To have an option called C<--start> that takes an integer as its value and can also be used with the names C<-s> and C<--begin>, declare as follows.\n" : "C<--start>というオプションを持ち、その値として整数を取り、C<-s>とC<--begin>という名前でも使えるようにするには、次のように宣言する。\n",
   "To produce accessor method, C<is> parameter is necessary. Set the value C<ro> for read-only, C<rw> for read-write.\n" : "アクセサメソッドを生成するには、C<is>パラメータが必要です。読み込み専用ならC<ro>、読み書きならC<rw>を指定します。\n",
   "Typical use of DEFAULT is C<is> to prepare accessor method for all following hash entries. Declare C<< DEFAULT => [] >> to reset.\n" : "DEFAULTの典型的な使い方はC<is>で、以下のすべてのハッシュ・エントリーのアクセサ・メソッドを用意することです。C<< DEFAULT => [] >>を宣言してリセットする。\n",
   "Use class method C<< Getopt::EX::Hashed->configure() >> before creating an object; this information is stored in the area unique for calling package. After calling C<new()>, package unique configuration is copied in the object, and it is used for further operation. Use C<< $obj->configure() >> to update object unique configuration.\n" : "オブジェクトを作成する前に、クラスメソッドC<< Getopt::EX::Hashed->configure() >>を使用します。C<new()>を呼び出すと、パッケージ固有の設定がオブジェクトにコピーされ、以降の操作に使用されます。オブジェクト固有の設定を更新するには、C<< $obj->configure() >> を使用します。\n",
   "When called, hash object is passed as C<$_>.\n" : "呼び出されたとき、ハッシュオブジェクトは C<$_> として渡されます。\n",
   "When specified, it is prepended to the member name to make accessor method. If C<ACCESSOR_PREFIX> is defined as C<opt_>, accessor for member C<file> will be C<opt_file>.\n" : "指定されると、メンバ名の前に付加されてアクセサ・メソッドとなる。C<ACCESSOR_PREFIX> が C<opt_> と定義されている場合、メンバ C<file> のアクセサは C<opt_file> になります。\n",
   "You can change this behavior by C<configure> with C<LOCK_KEYS> parameter.\n" : "この動作はC<configure>のC<LOCK_KEYS>パラメータで変更できます。\n",
   "You can use this for C<< \"<>\" >> to catch everything. In that case, spec parameter does not matter and not required.\n" : "これを C<< \"<>\" に使用することができる。\">>ですべてを捕らえることができる。その場合、specパラメータは重要ではなく、必須でもない。\n",
   "which conform to C<Getopt::Long> definition. Of course, you can write as this:\n" : "にコンパイルされ、C<Getopt::Long>の定義に従います。もちろん、このように書くこともできます：\n"
}
