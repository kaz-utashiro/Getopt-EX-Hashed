=encoding utf-8

=head1 NAME

Getopt::EX::Hashed - Getopt::Long 用ハッシュ格納オブジェクトの自動化

=head1 VERSION

Version 1.0601

=head1 SYNOPSIS

  # script/foo
  use App::foo;
  App::foo->new->run();

  # lib/App/foo.pm
  package App::foo;

  use Getopt::EX::Hashed; {
      Getopt::EX::Hashed->configure( DEFAULT => [ is => 'rw' ] );
      has start    => ' =i  s begin ' , default => 1;
      has end      => ' =i  e       ' ;
      has file     => ' =s@ f       ' , any => qr/^(?!\.)/;
      has score    => ' =i          ' , min => 0, max => 100;
      has answer   => ' =i          ' , must => sub { $_[1] == 42 };
      has mouse    => ' =s          ' , any => [ 'Frankie', 'Benjy' ];
      has question => ' =s          ' , any => qr/^(life|universe|everything)$/i;
  } no Getopt::EX::Hashed;

  sub run {
      my $app = shift;
      use Getopt::Long;
      $app->getopt or pod2usage();
      if ($app->answer == 42) {
          $app->question //= 'life';
          ...

=cut
=head1 DESCRIPTION

B<Getopt::EX::Hashed>は、B<Getopt::Long>およびB<Getopt::EX::Long>を含む互換モジュールのコマンドラインオプション値を格納するハッシュオブジェクトの作成を自動化するモジュールです。モジュール名はB<Getopt::EX>プレフィックスを共有していますが、これまでのところ、B<Getopt::EX>の他のモジュールとは独立して動作します。

このモジュールの主な目的は、初期化と仕様を一箇所に統合することです。また、簡単な検証インターフェースも提供します。

C<is>パラメータが与えられると、アクセサメソッドが自動的に生成されます。同じ関数がすでに定義されている場合、プログラムは致命的なエラーを引き起こします。アクセサはオブジェクトが破棄されると削除されます。複数のオブジェクトが同時に存在する場合、問題が発生する可能性があります。

=head1 FUNCTION

=head2 B<has>

オプション・パラメータを以下の形式で宣言します。括弧はわかりやすくするためのもので、省略してもよい。

    has option_name => ( param => value, ... );

たとえば、整数値をパラメータとしてとり、C<-n>としても使えるオプションC<--number>を定義するには、次のようにします。

    has number => spec => "=i n";

アクセサは最初の名前で作成されます。この例では、アクセサは C<< $app->number >> と定義されます。

配列参照が与えられている場合、複数の名前を一度に宣言することができます。

    has [ 'left', 'right' ] => ( spec => "=i" );

名前がプラス（C<+>）で始まる場合、与えられたパラメータは既存の設定を更新します。

    has '+left' => ( default => 1 );

C<spec>パラメータについては、最初のパラメータであればラベルを省略することができます。

    has left => "=i", default => 1;

パラメータの数が偶数でない場合、デフォルトのラベルが先頭に存在するものとみなされます：最初のパラメータがコード参照であればC<action>、そうでなければC<spec>となります。

以下のパラメータが利用可能です。

=over 7

=item [ B<spec> => ] I<string>

オプション指定C<< spec => >> ラベルを省略できるのは、それが最初のパラメータである場合だけです。

I<string> では、オプションの仕様とエイリアスの名前は空白で区切られ、どのような順番でも表示できます。

C<--start>というオプションを持ち、その値として整数を取り、C<-s>とC<--begin>という名前でも使えるようにするには、次のように宣言します。

    has start => "=i s begin";

上記の宣言は以下の文字列にコンパイルされます。

    start|s|begin=i

これは、C<Getopt::Long>の定義に準拠しています。もちろん、次のように書くこともできます：

    has start => "s|begin=i";

名前とエイリアスにアンダースコア(C<_>)が含まれている場合、アンダースコアの代わりにダッシュ(C<->)を使った別のエイリアスが定義されます。

    has a_to_z => "=s";

上記の宣言は以下の文字列にコンパイルされます。

    a_to_z|a-to-z=s

特に何もする必要がない場合は、空文字列（または空白のみ）を値として与えます。そうでない場合は、オプションとはみなされません。

=item B<alias> => I<string>

B<alias>パラメータで追加のエイリアス名を指定することもできます。C<spec>パラメータのものと違いはありません。

    has start => "=i", alias => "s begin";

=item B<is> => C<ro> | C<rw>

アクセサメソッドを生成するには、C<is>パラメータが必要です。読み込み専用ならC<ro>、読み書きならC<rw>を指定します。

読み書き可能なアクセサはlvalue属性を持っているので、それを代入することができます。このように使えます：

    $app->foo //= 1;

これは、次のように書くよりずっと簡単です。

    $app->foo(1) unless defined $app->foo;

以下のすべてのメンバに対してアクセサを作りたい場合は、C<configure>を使ってC<DEFAULT>パラメータを設定します。

    Getopt::EX::Hashed->configure( DEFAULT => [ is => 'rw' ] );

割り当て可能なアクセサを好まない場合は、C<ACCESSOR_LVALUE> パラメータを 0 に設定します。アクセサは C<new> の時点で生成されるため、この値はすべてのメンバに対して有効です。

=item B<default> => I<value> | I<coderef>

デフォルト値を設定します。デフォルト値が指定されない場合、メンバはC<undef>として初期化されます。

値がARRAYまたはHASHへの参照である場合、同じメンバを持つ新しい参照が割り当てられます。つまり、メンバ・データは複数のC<new>呼び出しにまたがって共有されます。C<new>を複数回呼び出してメンバ・データを変更する場合は注意してください。

コード参照が与えられている場合は、B<new>の時点で呼び出され、デフォルト値が取得されます。宣言ではなく実行時に値を評価したい場合に有効です。デフォルトのアクションを定義したい場合は、B<action>パラメータを使う。コード・リファレンスを初期値にしたい場合は、コード・リファレンスを返すコード・リファレンスを指定する必要があります。

SCALARへの参照が与えられた場合、オプション値はハッシュオブジェクトメンバではなく、参照が示すデータに格納されます。この場合、ハッシュ・メンバにアクセスしても期待値は得られません。

=item [ B<action> => ] I<coderef>

パラメータ C<action> は、オプションを処理するために呼び出されるコード参照をとます。C<<action =>> ラベルは、それが最初のパラメータである場合に限り、省略することができます。

呼び出されたとき、ハッシュオブジェクトは C<$_> として渡されます。

    has [ qw(left right both) ] => '=i';
    has "+both" => sub {
        $_->{left} = $_->{right} = $_[1];
    };

これをC<<"<>">> ですべてをキャッチすることができます。その場合、specパラメータは重要ではなく、必須ではありません。

    has ARGV => default => [];
    has "<>" => sub {
        push @{$_->{ARGV}}, $_[0];
    };

=back

以下のパラメータはすべてデータ検証のためのものです。まず、C<must>は汎用的なバリデータであり、何でも実装できます。その他は一般的なルールのショートカットです。

=over 7

=item B<must> => I<coderef> | [ I<coderef> ... ]

パラメータ C<must> は、オプション値を検証するためのコード参照を受け取ります。C<action>と同じ引数をとり、ブール値を返します。次の例では、オプションB<--answer>は有効な値として42だけを取ります。

    has answer => '=i',
        must => sub { $_[1] == 42 };

複数のコード参照が与えられた場合、すべてのコードが真を返さなければなりません。

    has answer => '=i',
        must => [ sub { $_[1] >= 42 }, sub { $_[1] <= 42 } ];

=item B<min> => I<number>

=item B<max> => I<number>

引数の最小値と最大値を設定します。

=item B<any> => I<arrayref> | qr/I<regex>/ | I<coderef>

有効な文字列パラメータリストを設定します。各項目は、文字列、正規表現参照、コード参照のいずれかです。引数は、指定されたリストのいずれかの項目と同じか一致する場合に有効です。値がarrayrefでない場合は、単一の項目リスト（通常は正規表現かコード参照）として扱われます。

以下の宣言はほぼ等価ですが、2番目の宣言は大文字小文字を区別しません。

    has question => '=s',
        any => [ 'life', 'universe', 'everything' ];

    has question => '=s',
        any => qr/^(life|universe|everything)$/i;

オプションの引数を使用する場合は、リストにデフォルト値を含めることを忘れないでください。そうしないとバリデーション・エラーになります。

    has question => ':s',
        any => [ 'life', 'universe', 'everything', '' ];

=back

=head1 METHOD

=head2 B<new>

新しいハッシュオブジェクトを作成するクラスメソッド。すべてのメンバをデフォルト値で初期化し、設定に従ってアクセサメソッドを作成します。ロックされたキーを持つ祝福されたハッシュ参照を返します (LOCK_KEYS が有効な場合)。

=head2 B<optspec>

C<GetOptions> 関数に渡すことができるオプション指定リストを返します。

    GetOptions($obj->optspec)

C<GetOptions> は、ハッシュ参照を最初の引数として与えることで、ハッシュに値を格納する機能を持っていますが、それは必要ありません。

=head2 B<getopt> [ I<arrayref> ]

呼び出し元のコンテキストで定義された適切な関数を呼び出してオプションを処理します。

    $obj->getopt

    $obj->getopt(\@argv);

上記の例は、以下のコードのショートカットです。

    GetOptions($obj->optspec)

    GetOptionsFromArray(\@argv, $obj->optspec)

=head2 B<use_keys> I<keys>

ハッシュキーはC<Hash::Util::lock_keys>によって保護されているため、存在しないメンバにアクセスするとエラーになります。この関数を使用して、使用前に新しいメンバー・キーを宣言してください。

    $obj->use_keys( qw(foo bar) );

任意のキーにアクセスしたい場合は、オブジェクトのロックを解除してください。

    use Hash::Util 'unlock_keys';
    unlock_keys %{$obj};

この動作はC<configure>のC<LOCK_KEYS>パラメータで変更できます。

=head2 B<configure> B<label> => I<value>, ...

オブジェクトを作成する前に、クラスメソッドC<< Getopt::EX::Hashed->configure() >>を使用します。C<new()>を呼び出すと、パッケージ固有の設定がオブジェクトにコピーされ、以降の操作に使用されます。オブジェクト固有の設定を更新するには、C<< $obj->configure() >> を使用します。

以下の設定パラメータが使用できます。

=over 7

=item B<LOCK_KEYS> (default: 1)

ハッシュ・キーをロックします。これにより、存在しないハッシュ・エントリへの偶発的なアクセスを避けることができます。

=item B<REPLACE_UNDERSCORE> (default: 1)

アンダースコアをダッシュに置き換えたエイリアスを生成します。

=item B<REMOVE_UNDERSCORE> (default: 0)

アンダースコアを除去したエイリアスを生成します。

=item B<GETOPT> (default: 'GetOptions')

=item B<GETOPT_FROM_ARRAY> (default: 'GetOptionsFromArray')

C<getopt> メソッドから呼び出される関数名を設定します。

=item B<ACCESSOR_PREFIX> (default: '')

指定すると、メンバ名の前に付加されてアクセサ・メソッドになります。C<ACCESSOR_PREFIX> が C<opt_> として定義されている場合、メンバ C<file> のアクセサは C<opt_file> になります。

=item B<ACCESSOR_LVALUE> (default: 1)

trueの場合、読み書きアクセサはlvalue属性を持つ。この動作を好まない場合はゼロに設定します。

=item B<DEFAULT>

デフォルト・パラメータを設定します。C<has>が呼び出されると、DEFAULTパラメータが引数パラメータの前に挿入されます。そのため、両方に同じパラメータが含まれている場合は、引数リストで後の方が優先されます。C<+>によるインクリメンタルコールは影響を受けないです。

DEFAULTの典型的な使い方は、C<is>で以下のすべてのハッシュ・エントリーのアクセサ・メソッドを用意することです。C<< DEFAULT => [] >>を宣言してリセットします。

    Getopt::EX::Hashed->configure(DEFAULT => [ is => 'ro' ]);

=begin comment

=item B<INVALID_MSG> (default: built-in error message generator)

検証失敗時のエラーメッセージを生成するコード・リファレンスを設定します。コード・リファレンスは、オプション・ハンドラと同じ引数を受け取ります ($_[0] はオプション名、$_[1] は単純オプションの値、$_[1] と $_[2] はハッシュ・オプションの値です)。デフォルトの関数は、"--option=value: option validation error" のようなメッセージを生成します。

    Getopt::EX::Hashed->configure(
        INVALID_MSG => sub {
            my $opt = shift;
            "Invalid value for --$opt: @_\n";
        }
    );

=end comment

=back

=head2 B<reset>

クラスを元の状態にリセットします。

=head1 SEE ALSO

L<Getopt::Long>

L<Getopt::EX>, L<Getopt::EX::Long>

=head1 AUTHOR

Kazumasa Utashiro

=head1 COPYRIGHT

The following copyright notice applies to all the files provided in
this distribution, including binary files, unless explicitly noted
otherwise.

Copyright 2021-2024 Kazumasa Utashiro

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
