{
   "Above declaration will be compiled into the next string.\n" : "上述声明将被编译为下一个字符串。\n",
   "Above examples are shortcut for following code.\n" : "以上示例是以下代码的快捷方式。\n",
   "Accessor methods are automatically generated when C<is> parameter is given. If the same function is already defined, the program causes fatal error. Accessors are removed when the object is destroyed. Problems may occur when multiple objects are present at the same time.\n" : "当给出 C<is> 参数时，将自动生成访问方法。如果已经定义了相同的函数，程序将导致致命错误。对象销毁时，访问器将被移除。当多个对象同时存在时，可能会出现问题。\n",
   "Additional alias names can be specified by B<alias> parameter too. There is no difference with ones in C<spec> parameter.\n" : "也可以通过 B<alias> 参数指定其他别名。这与 C<spec> 参数中的别名没有区别。\n",
   "As for C<spec> parameter, label can be omitted if it is the first parameter.\n" : "至于 C<spec> 参数，如果是第一个参数，则可以省略标签。\n",
   "B<Getopt::EX::Hashed> is a module to automate a hash object to store command line option values for B<Getopt::Long> and compatible modules including B<Getopt::EX::Long>. Module name shares B<Getopt::EX> prefix, but it works independently from other modules in B<Getopt::EX>, so far.\n" : "B<Getopt::EX::Hashed> 是一个模块，用于为 B<Getopt::Long> 和兼容模块（包括 B<Getopt::EX::Long>）自动创建一个哈希对象，以存储命令行选项值。模块名称共享 B<Getopt::EX> 前缀，但到目前为止，它独立于 B<Getopt::EX> 中的其他模块运行。\n",
   "Because hash keys are protected by C<Hash::Util::lock_keys>, accessing non-existent member causes an error. Use this function to declare new member key before use.\n" : "由于哈希键受 C<Hash::Util::lock_keys> 保护，访问不存在的成员会导致错误。在使用前，请使用此函数声明新的成员键。\n",
   "C<GetOptions> has a capability of storing values in a hash, by giving the hash reference as a first argument, but it is not necessary.\n" : "C<GetOptions> 可以通过将哈希引用作为第一个参数，将值存储在哈希对象中，但这并不是必须的。\n",
   "Call appropriate function defined in caller's context to process options.\n" : "调用调用者上下文中定义的适当函数来处理选项。\n",
   "Class method to get initialized hash object.\n" : "获取初始化哈希对象的类方法。\n",
   "Declare option parameters in a following form. The parentheses are for clarity only and may be omitted.\n" : "以下列形式声明选项参数。括号仅为清晰起见，可以省略。\n",
   "Following declarations are almost equivalent, except second one is case insensitive.\n" : "以下声明几乎等同，只是第二个声明不区分大小写。\n",
   "Following parameters are all for data validation. First C<must> is a generic validator and can implement anything. Others are shortcut for common rules.\n" : "以下参数均用于数据验证。首先，C<must> 是一个通用验证器，可以实现任何功能。其他参数是通用规则的快捷方式。\n",
   "Following parameters are available.\n" : "可使用以下参数\n",
   "For example, to define the option C<--number>, which takes an integer value as a parameter, and also can be used as C<-n>, do the following\n" : "例如，要定义以整数值为参数的选项 C<--number>（也可用作 C<-n>），请执行以下操作\n",
   "Getopt::EX::Hashed - Hash store object automation for Getopt::Long\n" : "Getopt::EX::Hashed - Getopt::Long 的哈希存储对象自动化\n",
   "Give option specification. C<< spec => >> label can be omitted if and only if it is the first parameter.\n" : "给出选项说明。C<< spec => >> 标签可以省略，前提是它是第一个参数。\n",
   "If a code reference is given, it is called at the time of B<new> to get default value. This is effective when you want to evaluate the value at the time of execution, rather than declaration. If you want to define a default action, use the B<action> parameter.\n" : "如果给出代码引用，则在 B<new> 时调用该代码引用以获取默认值。当您想在执行时而不是在声明时评估值时，这种方法非常有效。如果要定义默认操作，请使用 B<action> 参数。\n",
   "If a reference to SCALAR is given, the option value is stored in the data indicated by the reference, not in the hash object member. In this case, the expected value cannot be obtained by accessing the hash member.\n" : "如果给出 SCALAR 的引用，则选项值将存储在引用所指示的数据中，而不是哈希对象成员中。在这种情况下，无法通过访问哈希对象成员获得预期值。\n",
   "If array reference is given, multiple names can be declared at once.\n" : "如果给出数组引用，则可以同时声明多个名称。\n",
   "If multiple code reference is given, all code have to return true.\n" : "如果给出多个代码引用，则所有代码都必须返回 true。\n",
   "If nothing special is necessary, give empty (or white space only) string as a value. Otherwise, it is not considered as an option.\n" : "如果没有特殊需要，可将空字符串（或仅空白）作为值。否则，它将不被视为选项。\n",
   "If the name and aliases contain underscore (C<_>), another alias name is defined with dash (C<->) in place of underscores.\n" : "如果名称和别名中包含下划线 (C<_>)，则会用破折号 (C<->) 代替下划线定义另一个别名。\n",
   "If the name start with plus (C<+>), given parameter updates existing setting.\n" : "如果名称以加号（C<+>）开头，给定参数将更新现有设置。\n",
   "If the number of parameter is not even, default label is assumed to be exist at the head: C<action> if the first parameter is code reference, C<spec> otherwise.\n" : "如果参数个数不是偶数，则假定默认标签存在于头部：如果第一个参数是代码引用，则使用 C<action>，否则使用 C<spec>。\n",
   "If the value is a reference for ARRAY or HASH, new reference with same member is assigned. This means that member data is shared across multiple C<new> calls. Please be careful if you call C<new> multiple times and alter the member data.\n" : "如果值是 ARRAY 或 HASH 的引用，则会分配具有相同成员的新引用。这意味着成员数据将在多次调用 C<new> 时共享。如果多次调用 C<new> 并更改成员数据，请务必小心。\n",
   "If true, read-write accessors have lvalue attribute. Set zero if you don't like that behavior.\n" : "如果设置为 true，读写访问器将具有 lvalue 属性。如果不喜欢这种行为，请设置为 0。\n",
   "If you are using optional argument, don't forget to include default value in the list. Otherwise it causes validation error.\n" : "如果使用可选参数，不要忘记在列表中包含默认值。否则会导致验证错误。\n",
   "If you don't like assignable accessor, configure C<ACCESSOR_LVALUE> parameter to 0. Because accessor is generated at the time of C<new>, this value is effective for all members.\n" : "如果不喜欢可分配的访问器，可将 C<ACCESSOR_LVALUE> 参数设置为 0。 因为访问器是在 C<new> 时生成的，所以该值对所有成员都有效。\n",
   "If you want to access arbitrary keys, unlock the object.\n" : "如果要访问任意键，请解锁对象。\n",
   "If you want to make accessor for all following members, use C<configure> to set C<DEFAULT> parameter.\n" : "如果要为以下所有成员设置访问器，请使用 C<configure> 设置 C<DEFAULT> 参数。\n",
   "In I<string>, option spec and alias names are separated by white space, and can show up in any order.\n" : "在 I<string> 中，选项规格和别名用空白分隔，可以任意顺序出现。\n",
   "Lock hash keys. This avoids accidental access to non-existent hash entry.\n" : "锁定哈希键。这样可以避免意外访问不存在的哈希条目。\n",
   "Major objective of this module is integrating initialization and specification into single place. It also provides simple validation interface.\n" : "该模块的主要目标是将初始化和规范整合到一处。它还提供了简单的验证接口。\n",
   "Parameter C<action> takes code reference which is called to process the option. C<< action => >> label can be omitted if and only if it is the first parameter.\n" : "参数 C<action> 带有处理选项时调用的代码引用。如果 C<<action => >> 标签是第一个参数，则可以省略。\n",
   "Parameter C<must> takes a code reference to validate option values. It takes same arguments as C<action> and returns boolean. With next example, option B<--answer> takes only 42 as a valid value.\n" : "参数 C<must> 需要一个代码引用来验证选项值。它接收与 C<action> 相同的参数，并返回布尔值。在下一个例子中，选项 B<--answer> 只接受 42 作为有效值。\n",
   "Produce alias with underscores removed.\n" : "生成去掉下划线的别名。\n",
   "Produce alias with underscores replaced by dash.\n" : "生成用破折号替换下划线的别名。\n",
   "Read-write accessor has lvalue attribute, so it can be assigned to. You can use like this:\n" : "读写访问器具有 lvalue 属性，因此可以对其赋值。可以这样使用\n",
   "Reset the class to the original state.\n" : "将类重置为原始状态。\n",
   "Return option specification list which can be given to C<GetOptions> function.\n" : "返回可提供给 C<GetOptions> 函数的选项说明列表。\n",
   "Set default parameters. At the call for C<has>, DEFAULT parameters are inserted before argument parameters. So if both include same parameter, later one in argument list has precedence. Incremental call with C<+> is not affected.\n" : "设置默认参数。在调用 C<has> 时，DEFAULT 参数会插入到参数之前。因此，如果两个参数都包含相同的参数，参数列表中排在后面的参数优先。使用 C<+> 的递增调用不受影响。\n",
   "Set default value. If no default is given, the member is initialized as C<undef>.\n" : "设置默认值。如果没有给出缺省值，则成员初始化为 C<undef>。\n",
   "Set function name called from C<getopt> method.\n" : "设置 C<getopt> 方法调用的函数名。\n",
   "Set the minimum and maximum limit for the argument.\n" : "设置参数的最小和最大限制。\n",
   "Set the valid string parameter list. Each item is a string or a regex reference. The argument is valid when it is same as, or match to any item of the given list. If the value is not an arrayref, it is taken as a single item list (regexpref usually).\n" : "设置有效的字符串参数列表。每项都是字符串或 regex 引用。当参数与给定列表中的任何一项相同或匹配时，参数有效。如果参数值不是数组反射，则将其视为单项列表（通常是 regexpref）。\n",
   "The accessor is created with the first name. In this example, the accessor will be defined as C<< $app->number >>.\n" : "访问器以第一个名称创建。在本例中，访问器将定义为 C<< $app->number >>。\n",
   "There are following configuration parameters.\n" : "配置参数如下。\n",
   "This is much simpler than writing as in the following.\n" : "这比下面的写法要简单得多。\n",
   "To have an option called C<--start> that takes an integer as its value and can also be used with the names C<-s> and C<--begin>, declare as follows.\n" : "如果要使用一个名为 C<--start> 的选项，它的值是一个整数，并且还可以与 C<-s> 和 C<--begin> 一起使用，请声明如下。\n",
   "To produce accessor method, C<is> parameter is necessary. Set the value C<ro> for read-only, C<rw> for read-write.\n" : "要生成访问方法，必须使用 C<is> 参数。设置 C<ro> 表示只读，C<rw> 表示读写。\n",
   "Typical use of DEFAULT is C<is> to prepare accessor method for all following hash entries. Declare C<< DEFAULT => [] >> to reset.\n" : "DEFAULT 的典型用法是 C<is> 为下面所有哈希条目准备访问方法。声明 C<< DEFAULT => [] >> 以重置。\n",
   "Use class method C<< Getopt::EX::Hashed->configure() >> before creating an object; this information is stored in the area unique for calling package. After calling C<new()>, package unique configuration is copied in the object, and it is used for further operation. Use C<< $obj->configure() >> to update object unique configuration.\n" : "在创建对象之前，请使用类方法 C<< Getopt::EX::Hashed->configure() >>；此信息存储在调用包的唯一区域。调用 C<new()> 后，包的唯一配置将复制到对象中，并用于进一步操作。使用 C<< $obj->configure() >> 更新对象的唯一配置。\n",
   "When called, hash object is passed as C<$_>.\n" : "调用时，哈希对象作为 C<$_> 传递。\n",
   "When specified, it is prepended to the member name to make accessor method. If C<ACCESSOR_PREFIX> is defined as C<opt_>, accessor for member C<file> will be C<opt_file>.\n" : "指定后，它将作为成员名的前缀，用于生成访问方法。如果 C<ACCESSOR_PREFIX> 被定义为 C<opt_>，则成员 C<file> 的访问器将是 C<opt_file>。\n",
   "You can change this behavior by C<configure> with C<LOCK_KEYS> parameter.\n" : "您可以通过带有 C<LOCK_KEYS> 参数的 C<configure> 改变这种行为。\n",
   "You can use this for C<< \"<>\" >> to catch everything. In that case, spec parameter does not matter and not required.\n" : "您可以将其用于 C<< \"<>\">> 来捕获所有内容。在这种情况下，规格参数并不重要，也不是必需的。\n",
   "which conform to C<Getopt::Long> definition. Of course, you can write as this:\n" : "符合 C<Getopt::Long> 的定义。当然，也可以这样写：\n"
}
